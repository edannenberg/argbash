#!/bin/bash

_help_command_description="bar command description goes here"

# ARGBASH_WRAP([opt-global])
# ARG_OPTIONAL_SINGLE([bar-option],[o],[A option with short and long flags and default],[boo])
# ARG_POSITIONAL_SINGLE([bar-arg],[Positional arg description for bar command],[])
# ARG_HELP([])
# ARGBASH_SET_INDENT([    ])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.3.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info

die()
{
    local _ret=$2
    test -n "$_ret" || _ret=1
    test "$_PRINT_HELP" = yes && print_help >&2
    echo "$1" >&2
    exit ${_ret}
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_print=off
_arg_bar_option="boo"

print_help ()
{
    printf 'Usage: %s [--(no-)print] [-o|--bar-option <arg>] [-h|--help] <bar-arg>\n' "$0"
    printf "\t%s\n" "<bar-arg>: Positional arg description for bar command"
    printf "\t%s\n" "--print,--no-print: A boolean option with long flag (and implicit default: off) (off by default)"
    printf "\t%s\n" "-o,--bar-option: A option with short and long flags and default (default: '"boo"')"
    printf "\t%s\n" "-h,--help: Prints help"
}

# THE PARSING ITSELF
while test $# -gt 0
do
    _key="$1"
    case "$_key" in
        --no-print|--print)
            _arg_print="on"
            _args_opt_global_opt+=("${_key%%=*}")
            test "${1:0:5}" = "--no-" && _arg_print="off"
            ;;
        -o*|--bar-option|--bar-option=*)
            _val="${_key##--bar-option=}"
            _val2="${_key##-o}"
            if test "$_val" = "$_key"
            then
                test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
                _val="$2"
                shift
            elif test "$_val2" != "$_key" -a -n "$_val2"
            then
                _val="$_val2"
            fi
            _arg_bar_option="$_val"
            ;;
        -h*|--help)
            print_help
            exit 0
            ;;
        *)
            _positionals+=("$1")
            ;;
    esac
    shift
done

_positional_names=('_arg_bar_arg' )
test ${#_positionals[@]} -lt 1 && _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require exactly 1, but got only ${#_positionals[@]}." 1
test ${#_positionals[@]} -gt 1 && _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect exactly 1, but got ${#_positionals[@]} (the last one was: '${_positionals[*]: -1}')." 1
for (( ii = 0; ii < ${#_positionals[@]}; ii++))
do
    eval "${_positional_names[ii]}=\${_positionals[ii]}" || die "Error during argument parsing, possibly an Argbash bug." 1
done

# OTHER STUFF GENERATED BY Argbash
_args_opt_global=("${_args_opt_global_opt[@]}" "${_args_opt_global_pos[@]}")

### END OF CODE GENERATED BY Argbash (sortof) ### ])
